using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Threading.Tasks;

namespace DiabasePrintingWizard
{
    class GCodeProcessor
    {
        private static readonly double DefaultFeedrate = 3000.0 / 60.0;         // see RRF in Configuration.h

        private static readonly double ToolChangeDuration = 2.0;                // in s
        private static readonly double ToolChangeDurationWithCleaning = 2.0;   // in s

        private static readonly double OneeightyOverPI = 180 / Math.PI;

        private static readonly string ToolChangeMarker = " ; tool change";

        private FileStream input;
        private SettingsContainer settings;
        private readonly IList<OverrideRule> rules;
        private readonly Duet.MachineInfo machineInfo;
        private IProgress<int> progress;
        private IProgress<int> maxProgress;

        private List<GCodeLayer> layers;

        private List<bool> toolPrimed;
        private double toolChangeRetractionDistance = 10.0;
        private double toolChangeRetractionSpeed = 3600;

        private Coordinate lastPoint;
        private Coordinate homingPosition;
        private Coordinate afterProbingPosition;

        public GCodeProcessor(FileStream stream, SettingsContainer preferences, IList<OverrideRule> ruleSet, Duet.MachineInfo machine,
            IProgress<int> setProgress, IProgress<int> setMaxProgress)
        {
            input = stream;
            settings = preferences;
            rules = ruleSet;
            machineInfo = machine;
            progress = setProgress;
            maxProgress = setMaxProgress;

            layers = new List<GCodeLayer>();
            toolPrimed = new List<bool>();
            for (int i = 0; i < preferences.Tools.Length; i++)
            {
                toolPrimed.Add(false);
            }
            lastPoint = new Coordinate();
            // TODO: Make configurable?
            homingPosition = new Coordinate() { X = -210, Y = -90, Z = 200 };
            afterProbingPosition = new Coordinate() { X = 180, Y = 80, Z = 0 };
        }

        // Split up the G-code file into different segments holding corresponding G-code lines plus feedrate
        // Each segment is created when
        // - the tool number OR
        // - the print region as indicated by S3D ("; feature..." or "; ...")
        // changes.
        // These segments are combined later on in the post-processing step
        public async Task PreProcess()
        {
            StreamReader reader = new StreamReader(input);
            string lineBuffer = await reader.ReadLineAsync();
            if (lineBuffer == null)
            {
                throw new ProcessorException("File is empty");
            }

            if (lineBuffer.Contains("G-Code generated by Simplify3D(R)"))
            {
                maxProgress.Report((int)input.Length);

                double feedrate = DefaultFeedrate;
                double firstLayerHeight = 0;
                bool rotaryPrinting = settings.RotaryPrinting != null;
                int lineNumber = 1, numExtrusions = 0;
                bool isInterfacingSet = true;
                GCodeLayer layer = new GCodeLayer(0, 0.0), lastLayer = null;
                GCodeSegment segment = new GCodeSegment("Initialization", -1, null);
                layer.Segments.Add(segment);

                HashSet<int> usedTools = new HashSet<int>();

                do
                {
                    bool writeLine = true;
                    GCodeLine line = new GCodeLine(lineBuffer);

                    if (lineBuffer.StartsWith(";", StringComparison.InvariantCulture))
                    {
                        if (lineBuffer.StartsWith("; layer ", StringComparison.InvariantCulture))
                        {
                            segment.LastPosition = lastPoint.Clone();
                            // Add past layer
                            layers.Add(layer);
                            lastLayer = layer;

                            // Get the Z height. S3D provides it via the comment except before the end
                            string lastParameter = lineBuffer.Split(' ').Last();
                            double zHeight = (lastParameter == "end") ? double.NaN : double.Parse(lastParameter, FrmMain.numberFormat);
                            if (lineBuffer.StartsWith("; layer 1, Z =", StringComparison.InvariantCulture))
                            {
                                firstLayerHeight = zHeight;
                            }

                            // Create a new one
                            layer = new GCodeLayer(layer.Number + 1, zHeight);
                            segment = new GCodeSegment(lineBuffer, segment.Tool, segment);
                            layer.Segments.Add(segment);
                            isInterfacingSet = layer.Number < 2;
                        }
                        else if ((layer.Number == 0 && lineNumber > 2 && !lineBuffer.Contains("layerHeight"))
                                    || lineBuffer.StartsWith("; tool", StringComparison.InvariantCulture)
                                    || lineBuffer.StartsWith("; process", StringComparison.InvariantCulture))
                        {
                            // Keep first two comment lines but get rid of S3D process description and
                            // remove "; tool" as well as "; process" lines because they are completely useless
                            writeLine = false;

                            // Try to get the tool change parameters
                            if (lineBuffer.Contains("toolChangeRetractionDistance"))
                            {
                                double? value = line.GetFValue(',', true);
                                if (value.HasValue) { toolChangeRetractionDistance = value.Value; }
                            }
                            if (lineBuffer.Contains("toolChangeRetractionSpeed"))
                            {
                                double? value = line.GetFValue(',', true);
                                if (value.HasValue) { toolChangeRetractionSpeed = value.Value; }
                            }
                        }
                        else if (layer.Number > 0)
                        {
                            // T-codes are generated just before a new segment starts
                            string region = lineBuffer.Substring(lineBuffer.StartsWith("; feature", StringComparison.InvariantCulture) ? 9 : 1).Trim();
                            if (segment.Lines.Count == 0)
                            {
                                segment.Name = region;
                            }
                            else
                            {
                                segment = new GCodeSegment(region, segment.Tool, segment);
                                layer.Segments.Add(segment);
                            }
                        }
                    }
                    else
                    {
                        int? gCode = line.GetIValue('G');
                        if (gCode.HasValue)
                        {
                            // G0 / G1
                            if (gCode == 0 || gCode == 1)
                            {
                                double? xParam = line.GetFValue('X');
                                double? yParam = line.GetFValue('Y');
                                double? zParam = line.GetFValue('Z');
                                if (xParam.HasValue) { lastPoint.X = xParam.Value; }
                                if (yParam.HasValue)
                                {
                                    if (rotaryPrinting)
                                    {
                                        yParam = HandleRescale(firstLayerHeight, line, yParam);
                                    }
                                    lastPoint.Y = yParam.Value;
                                }
                                if (zParam.HasValue) { lastPoint.Z = zParam.Value; }

                                if (numExtrusions < 2)
                                {
                                    if (line.GetFValue('E').HasValue)
                                    {
                                        numExtrusions++;
                                        writeLine = false;
                                    }
                                }

                                double? fParam = line.GetFValue('F');
                                if (fParam.HasValue) { feedrate = fParam.Value / 60.0; }

                                if (!isInterfacingSet && segment.Tool != -1 && xParam.HasValue && yParam.HasValue)
                                {
                                    segment.IsInterfacing = GetClosestSegment(lastLayer, xParam.Value, yParam.Value)?.Tool != segment.Tool;
                                    isInterfacingSet = true;
                                }
                            }
                            // G10
                            else if (gCode == 10)
                            {
                                int? pParam = line.GetIValue('P');
                                double? sParam = line.GetFValue('S');
                                if (pParam.HasValue && pParam.Value > 0 && pParam.Value <= settings.Tools.Length && sParam.HasValue)
                                {
                                    // G10 P... S...
                                    settings.Tools[pParam.Value - 1].ActiveTemperature = (decimal)sParam.Value;
                                }
                            }
                            else if (gCode == 28)
                            {
                                lastPoint = homingPosition.Clone();
                            }
                            else if (gCode == 32)
                            {
                                lastPoint = afterProbingPosition.Clone();
                            }
                        }
                        else
                        {
                            int? mCode = line.GetIValue('M');
                            if (mCode.HasValue)
                            {
                                // M104
                                if (mCode == 104)
                                {
                                    double? sParam = line.GetFValue('S');
                                    int? tParam = line.GetIValue('T');
                                    if (sParam.HasValue && tParam.HasValue && tParam.Value > 0 && tParam.Value <= settings.Tools.Length)
                                    {
                                        ToolSettings toolSettings = settings.Tools[tParam.Value - 1];
                                        if (toolSettings.Type == ToolType.Nozzle)
                                        {
                                            if (toolSettings.ActiveTemperature <= 0m)
                                            {
                                                toolSettings.ActiveTemperature = (decimal)sParam.Value;
                                                segment.AddLine($"G10 P{tParam} R{toolSettings.StandbyTemperature.ToString(FrmMain.numberFormat)} S{toolSettings.ActiveTemperature.ToString(FrmMain.numberFormat)}");
                                            }
                                            else
                                            {
                                                segment.AddLine($"G10 P{tParam} S{sParam.Value.ToString(FrmMain.numberFormat)}");
                                            }
                                        }
                                        writeLine = false;
                                    }
                                }
                            }
                            else
                            {
                                // T-Code
                                int? tCode = line.GetIValue('T');
                                if (tCode.HasValue)
                                {
                                    if (tCode > 0 && tCode <= settings.Tools.Length)
                                    {
                                        usedTools.Add(tCode.Value);
                                        if (settings.Tools[tCode.Value - 1].Type == ToolType.Nozzle)
                                        {
                                            // Keep track of tools in use. Tool change sequences are inserted by the post-processor
                                            if (segment.Lines.Count <= 1)
                                            {
                                                segment.Tool = tCode.Value;
                                            }
                                            else
                                            {
                                                segment = new GCodeSegment(segment.Name, tCode.Value, segment);
                                                layer.Segments.Add(segment);
                                            }
                                            writeLine = false;
                                        }
                                        else
                                        {
                                            // Make sure we don't print with inproperly configured tools...
                                            throw new ProcessorException($"Tool {tCode} is not configured as a nozzle (see line {lineNumber})");
                                        }
                                    }
                                    else if (segment.Lines.Count == 0)
                                    {
                                        segment.Tool = -1;
                                    }
                                    else
                                    {
                                        segment = new GCodeSegment(segment.Name, -1, segment);
                                        layer.Segments.Add(segment);
                                    }
                                }
                            }
                        }
                    }

                    // Add this line unless it was handled before
                    if (writeLine)
                    {
                        line.Feedrate = feedrate;
                        segment.AddLine(line);
                    }
                    lineBuffer = await reader.ReadLineAsync();
                    lineNumber++;

                    // Report progress to the UI
                    progress.Report((int)input.Position);
                } while (lineBuffer != null);

                layers.Add(layer);
                RemoveHeatingOfUnusedTools(usedTools);
                if (rotaryPrinting)
                {
                    RotaryPrintingFixes();
                }
            }
            else if (lineBuffer.Contains("Diabase"))
            {
                throw new ProcessorException("File has been already processed");
            }
            else
            {
                throw new ProcessorException("File was not generated by Simplify3D");
            }
        }

        private void RotaryPrintingFixes()
        {
            if (layers.Count == 0 || layers[0].Segments.Count == 0)
            {
                return;
            }
            GCodeSegment initialization = layers[0].Segments[0];
            for (int i = 0; i < initialization.Lines.Count; i++)
            {
                GCodeLine line = initialization.Lines[i];
                if (line.Content.StartsWith("G28", StringComparison.InvariantCulture))
                {
                    initialization.Lines.RemoveAt(i);
                    // We need to manually decrement i to not miss the next line
                    --i;
                }
                else if (line.Content.StartsWith("G32", StringComparison.InvariantCulture))
                {
                    initialization.Lines.RemoveAt(i);
                    initialization.Lines.Insert(i, new GCodeLine("G29 S1 ; Load height map"));
                    break;
                }
            }

        }

        private void RemoveHeatingOfUnusedTools(HashSet<int> usedTools)
        {
            // Filter out heating for unsused tools
            foreach (GCodeLayer l in layers)
            {
                foreach (GCodeSegment s in l.Segments)
                {
                    for (int i = 0; i < s.Lines.Count; i++)
                    {
                        GCodeLine line = s.Lines[i];
                        if (line.Content.StartsWith("G10 P", StringComparison.InvariantCulture))
                        {
                            int? toolNo = line.GetIValue('P');
                            if (!usedTools.Contains(toolNo.Value))
                            {
                                // If this tool was never called remove it's heating command
                                s.Lines.RemoveAt(i);
                                // We need to manually decrement i to not miss the next line
                                --i;
                            }
                        }
                    }
                }
            }
        }

        private double? HandleRescale(double firstLayerHeight, GCodeLine line, double? yParam)
        {
            double scaledY = yParam.Value * (OneeightyOverPI / (settings.RotaryPrinting.InnerRadius + lastPoint.Z - firstLayerHeight));
            if (!line.UpdateFValue('Y', scaledY))
            {
                throw new ProcessorException($"Y could not be updated on {line.Content}");
            }
            yParam = line.GetFValue('Y');

            return yParam;
        }

        private GCodeSegment GetClosestSegment(GCodeLayer layer, double x, double y)
        {
            GCodeSegment minSegment = null;
            double minDistance = 0.0;
            double lastX = double.NaN, lastY = double.NaN;
            foreach (GCodeSegment segment in layer.Segments)
            {
                foreach (GCodeLine line in segment.Lines)
                {
                    int? gCode = line.GetIValue('G');
                    if (gCode == 0 || gCode == 1)
                    {
                        double? xCoord = line.GetFValue('X');
                        double? yCoord = line.GetFValue('Y');
                        if (xCoord.HasValue && yCoord.HasValue)
                        {
                            if (double.IsNaN(lastX) || double.IsNaN(lastY))
                            {
                                lastX = xCoord.Value;
                                lastY = yCoord.Value;
                            }
                            else if (line.GetFValue('E').HasValue)
                            {
                                // Get distance from the extruding G0/G1 line segment ([lastX, lastY] to [xCoord, yCoord]) to [x, y]
                                double distance = Math.Abs((yCoord.Value - lastY) * x - (xCoord.Value - lastX) * y + xCoord.Value * lastY - yCoord.Value * lastX) /
                                    Math.Sqrt(Math.Pow(yCoord.Value - lastY, 2) + Math.Pow(xCoord.Value - lastX, 2));
                                if (minSegment == null || distance < minDistance)
                                {
                                    minSegment = segment;
                                    minDistance = distance;
                                }
                            }
                        }
                    }
                }
            }
            return minSegment;
        }

        private OverrideRule GetRule(int tool, int layer, GCodeSegment segment)
        {
            foreach (OverrideRule rule in rules)
            {
                if (rule.Matches(tool, layer, segment))
                {
                    return rule;
                }
            }
            return null;
        }

        public void PostProcess()
        {
            // We know how much we need to do here...
            maxProgress.Report(Math.Max(layers.Count * 4 - 4, 0));

            // Combine tool islands per layer, adjust tool change sequences and take care of rules
            OverrideRule activeRule = null;
            int iteration = 1;
            bool startWithLowestTool = true;
            int currentTool = -1;

            for (int layerIndex = 1; layerIndex < layers.Count; layerIndex++)
            {
                GCodeLayer layer = layers[layerIndex];
                GCodeLayer replacementLayer = new GCodeLayer(layerIndex, layer.ZHeight);

                if (settings.IslandCombining)
                {
                    if (startWithLowestTool)
                    {
                        for (int toolNumber = 1; toolNumber <= settings.Tools.Length; toolNumber++)
                        {
                            // Go from T1-T5
                            GCodeSegment segment = CombineSegments(layer, toolNumber, ref currentTool, ref activeRule);
                            if (segment != null) { replacementLayer.Segments.Add(segment); }
                        }
                    }
                    else
                    {
                        for (int toolNumber = settings.Tools.Length; toolNumber >= 1; toolNumber--)
                        {
                            // Go from T5-T1
                            GCodeSegment segment = CombineSegments(layer, toolNumber, ref currentTool, ref activeRule);
                            if (segment != null) { replacementLayer.Segments.Add(segment); }
                        }
                    }
                    startWithLowestTool = !startWithLowestTool;
                }
                else
                {
                    double currentZ = 0.0;
                    foreach (GCodeSegment segment in layer.Segments)
                    {
                        int toolNumber = segment.Tool;
                        List<GCodeLine> replacementLines = new List<GCodeLine>();
                        Coordinate lastPosition = EnrichSegment(layer, segment, replacementLines, toolNumber, ref currentTool, ref activeRule, ref currentZ);
                        if (replacementLines.Count > 0)
                        {
                            replacementLayer.Segments.Add(
                            new GCodeSegment($"T{toolNumber}", toolNumber, null)
                            {
                                Lines = replacementLines,
                                LastPosition = lastPosition
                            });
                        }
                    }
                }

                layers[layerIndex] = replacementLayer;
                progress.Report(iteration++);
            }

            // Make sure the last applied rule is reset before the print finishes
            if (activeRule != null)
            {
                GCodeSegment lastSegment = layers.Last((layer) => layer.Segments.Count > 0).Segments.Last();
                if (activeRule.SpeedFactor != 100) { lastSegment.Lines.Add(new GCodeLine("M220 S100")); }
                if (activeRule.ExtrusionFactor != 100) { lastSegment.Lines.Add(new GCodeLine("M221 S100")); }
                activeRule = null;
            }

            FixToolChangeRetractionAndPriming(ref iteration);

            InsertPreheatingSequences(ref iteration);
        }

        private void FixToolChangeRetractionAndPriming(ref int iteration)
        {
            // Fix toolchange retraction/priming
            for (int layerNumber = 1; layerNumber < layers.Count; layerNumber++)
            {
                GCodeLayer layer = layers[layerNumber];
                for (int segmentNumber = 0; segmentNumber < layer.Segments.Count; segmentNumber++)
                {
                    GCodeSegment segment = layer.Segments[segmentNumber];
                    for (int lineIndex = 0; lineIndex < segment.Lines.Count; lineIndex++)
                    {
                        GCodeLine line = segment.Lines[lineIndex];
                        // Look for toolchange
                        if (!line.Content.EndsWith(ToolChangeMarker, StringComparison.InvariantCulture))
                        {
                            continue;
                        }

                        // Search for retraction prior to toolchange
                        // It will be located at the end of the previous segment
                        var previousSegment = GetPreviousSegment(layerNumber, segmentNumber);
                        if (previousSegment != null)
                        {
                            var lookbehindLimit = Math.Max(previousSegment.Lines.Count - 5, 0);
                            for (var reverse = previousSegment.Lines.Count - 1; reverse >= lookbehindLimit; reverse--)
                            {
                                if (!previousSegment.Lines[reverse].Content.StartsWith("G1 E-", StringComparison.InvariantCulture))
                                {
                                    continue;
                                }
                                var eVal = previousSegment.Lines[reverse].GetFValue('E');
                                if (Math.Abs(eVal.Value) != toolChangeRetractionDistance)
                                {
                                    previousSegment.Lines.RemoveAt(reverse);
                                    previousSegment.Lines.Insert(reverse, new GCodeLine($"G1 E-{toolChangeRetractionDistance.ToString("F2", FrmMain.numberFormat)} F{toolChangeRetractionSpeed.ToString(FrmMain.numberFormat)}", toolChangeRetractionSpeed / 60.0));
                                }
                                break;
                            }
                        }

                        // Search for priming post toolchange
                        var lookaheadLimit = Math.Min(lineIndex + 5, segment.Lines.Count - 1);
                        for (var forward = lineIndex + 1; forward <= lookaheadLimit; forward++)
                        {
                            if (!segment.Lines[forward].Content.StartsWith("G1 E", StringComparison.InvariantCulture))
                            {
                                continue;
                            }
                            var eVal = segment.Lines[forward].GetFValue('E');
                            if (eVal.Value != toolChangeRetractionDistance)
                            {
                                segment.Lines.RemoveAt(forward);
                                segment.Lines.Insert(forward, new GCodeLine($"G1 E{toolChangeRetractionDistance.ToString("F2", FrmMain.numberFormat)} F{toolChangeRetractionSpeed.ToString(FrmMain.numberFormat)}", toolChangeRetractionSpeed / 60.0));
                            }
                            break;
                        }
                    }
                }
                progress.Report(iteration++);
            }
        }

        private GCodeSegment GetPreviousSegment(int layerNumber, int segmentNumber)
        {
            // Previous segment in same layer
            if (segmentNumber > 0)
            {
                return layers[layerNumber].Segments[segmentNumber - 1];
            }

            // Check if there is a previous layer with segments
            if (layerNumber > 0 && layers[layerNumber - 1].Segments.Count > 0)
            {
                return layers[layerNumber - 1].Segments.Last();
            }

            // No previous segment available
            return null;
        }

        private void InsertPreheatingSequences(ref int iteration)
        {
            // Check if at least one tool needs preheating or quit otherwise
            if (!settings.Tools.Any(tool => tool.PreheatTime > 0.0m))
            {
                iteration += layers.Count * 2 - 1;
                progress.Report(iteration);
                return;
            }
            var preheatCounters = new Dictionary<int, double>();   // Tool number vs. Elapsed time
            var position = new Coordinate();
            var previousPosition = position.Clone();

            // First calculate duration of each line
            for (var layerNumber = 0; layerNumber < layers.Count - 1; layerNumber++)
            {
                var layer = layers[layerNumber];
                foreach (var segment in layer.Segments)
                {
                    foreach (var line in segment.Lines)
                    {
                        int? gCode = line.GetIValue('G');

                        // G0 / G1
                        if (gCode == 0 || gCode == 1)
                        {
                            var xParam = line.GetFValue('X');
                            var yParam = line.GetFValue('Y');
                            var zParam = line.GetFValue('Z');
                            var eParam = line.GetFValue('E');
                            if (xParam.HasValue) { position.X = xParam.Value; }
                            if (yParam.HasValue) { position.Y = yParam.Value; }
                            if (zParam.HasValue) { position.Z = zParam.Value; }

                            line.Distance =
                                Math.Sqrt(
                                    Math.Pow(position.X - previousPosition.X, 2) +
                                    Math.Pow(position.Y - previousPosition.Y, 2) +
                                    Math.Pow(position.Z - previousPosition.Z, 2) +
                                    (eParam.HasValue ? Math.Pow(eParam.Value, 2) : 0)
                                );
                            if (line.Feedrate > 0.0)
                            {
                                var rule = GetRule(segment.Tool, layerNumber, segment);
                                var feedrate = line.Feedrate * (rule == null ? 1 : (rule.SpeedFactor / 100.0));
                                // TODO: Take into account accelerations here?
                                line.Duration = line.Distance / feedrate;
                            }

                            previousPosition.AssignFrom(position);
                        }
                        else if (gCode == 4)
                        {
                            var sParam = line.GetFValue('S');
                            if (sParam.HasValue)
                            {
                                line.Duration = sParam.Value;
                            }
                            else
                            {
                                var pParam = line.GetIValue('P');
                                if (pParam.HasValue)
                                {
                                    line.Duration = pParam.Value / 1000.0;
                                }
                            }
                        }
                        else if (gCode == 28)
                        {
                            previousPosition.AssignFrom(homingPosition);
                            position.AssignFrom(homingPosition);
                        }
                        else if (gCode == 32)
                        {
                            previousPosition.AssignFrom(afterProbingPosition);
                            position.AssignFrom(afterProbingPosition);
                        }
                    }
                }
                progress.Report(iteration++);
            }

            // Now go through the file backwards and insert preheating commands
            for (var layerNumber = layers.Count - 1; layerNumber >= 1; layerNumber--)
            {
                var layer = layers[layerNumber];

                // Start at last segment in layer
                for (var segmentNumber = layer.Segments.Count - 1; segmentNumber >= 0; segmentNumber--)
                {
                    var segment = layer.Segments[segmentNumber];

                    // Start at last line in layer
                    for (var lineNumber = segment.Lines.Count - 1; lineNumber >= 0; lineNumber--)
                    {
                        var line = segment.Lines[lineNumber];

                        // We found a tool change
                        if (line.Content.EndsWith(ToolChangeMarker, StringComparison.InvariantCulture))
                        {
                            // Take into account tool change times
                            var tool = settings.Tools[segment.Tool - 1];

                            // See if we need to use preheating for this tool
                            if (tool.PreheatTime > 0.0m)
                            {
                                // Reset possibly existing preheating time to just the tool change time
                                // In case we were already waiting we will have to wait even longer.
                                preheatCounters[segment.Tool] = line.Content.StartsWith("M98 P\"tprime", StringComparison.InvariantCulture) ? ToolChangeDurationWithCleaning : ToolChangeDuration;
                            }
                        }

                        // We only care for other commands if we are taking time
                        if (preheatCounters.Count > 0)
                        {
                            var timeSpent = 0.0;
                            if (line.Duration.HasValue)
                            {
                                timeSpent = line.Duration.Value;
                            }
                            int? gCode = line.GetIValue('G');
                            if (gCode == 10)
                            {
                                var pParam = line.GetIValue('P');
                                var rParam = line.GetIValue('R');
                                if (pParam.HasValue && rParam.HasValue && pParam > 0 && pParam <= settings.Tools.Length)
                                {
                                    if (preheatCounters.ContainsKey(pParam.Value))
                                    {
                                        // Remove this line again if we are still preheating
                                        segment.Lines.RemoveAt(lineNumber);
                                    }
                                }
                            }

                            // Check if any of the tools we want to preheat has had enough time to do so yet
                            foreach (var toolNumber in preheatCounters.Keys.ToList())
                            {
                                var tool = settings.Tools[toolNumber - 1];
                                var totalTimeSpent = preheatCounters[toolNumber] + timeSpent;
                                if (totalTimeSpent > (double)tool.PreheatTime)
                                {
                                    // We've been doing enough stuff to generate a good G10 code
                                    segment.Lines.Insert(lineNumber, new GCodeLine($"G10 P{toolNumber} R{tool.ActiveTemperature.ToString(FrmMain.numberFormat)}"));
                                    preheatCounters.Remove(toolNumber);
                                }
                                else
                                {
                                    // Need to do some more...
                                    preheatCounters[toolNumber] = totalTimeSpent;
                                }
                            }
                        }
                    }
                }
                progress.Report(iteration++);
            }

            // Override first generated G10 codes if we could not preheat in time
            if (preheatCounters.Count > 0 && layers.Count > 0 && layers[0].Segments.Count > 0)
            {
                foreach (GCodeLine line in layers[0].Segments[0].Lines)
                {
                    int? gCode = line.GetIValue('G');
                    if (gCode == 10)
                    {
                        int? pParam = line.GetIValue('P');
                        if (pParam.HasValue && preheatCounters.ContainsKey(pParam.Value))
                        {
                            ToolSettings tool = settings.Tools[pParam.Value - 1];
                            var activeTemp = tool.ActiveTemperature.ToString(FrmMain.numberFormat);
                            line.Content = $"G10 P{pParam} R{activeTemp} S{activeTemp}";
                            preheatCounters.Remove(pParam.Value);
                        }
                    }
                }
            }
        }

        // Perform island combination for a given tool on a given layer returning a segment for the selected tool
        private GCodeSegment CombineSegments(GCodeLayer layer, int toolNumber, ref int currentTool, ref OverrideRule activeRule, int startSegment = 0)
        {
            if (settings.Tools[toolNumber - 1].Type != ToolType.Nozzle)
            {
                // Don't bother with unconfigured tools
                return null;
            }

            List<GCodeLine> replacementLines = new List<GCodeLine>();
            double currentZ = 0.0;
            Coordinate lastPosition = null;
            foreach (GCodeSegment segment in layer.Segments)
            {
                // Filter to the requested tool
                if (segment.Tool == toolNumber)
                {
                    lastPosition = EnrichSegment(layer, segment, replacementLines, toolNumber, ref currentTool, ref activeRule, ref currentZ);
                }
            }
            return (replacementLines.Count == 0) ? null : new GCodeSegment($"T{toolNumber}", toolNumber, null) { Lines = replacementLines, LastPosition = lastPosition };
        }

        private Coordinate EnrichSegment(GCodeLayer layer, GCodeSegment segment, List<GCodeLine> replacementLines, int toolNumber, ref int currentTool, ref OverrideRule activeRule, ref double currentZ)
        {
            bool primeTool = false;
            bool ensureUnhopAfterToolChange = false;
            foreach (GCodeLine line in segment.Lines)
            {

                // Get GCode of current line
                int? gCode = line.GetIValue('G');

                // Movement
                if (gCode == 0 || gCode == 1)
                {
                    // Keep track of the current Z position
                    double? zPosition = line.GetFValue('Z');
                    if (zPosition.HasValue)
                    {
                        currentZ = zPosition.Value;

                        // Since we have a Z height in this line we don't have to insert an artificial one
                        ensureUnhopAfterToolChange = false;
                    }

                    // Make sure to un-hop before the first extrusion if required
                    if (!double.IsNaN(layer.ZHeight) && line.GetFValue('E').HasValue && (currentZ != layer.ZHeight || ensureUnhopAfterToolChange))
                    {
                        replacementLines.Add(new GCodeLine($"G1 Z{layer.ZHeight.ToString("F3", FrmMain.numberFormat)} F{(line.Feedrate * 60.0).ToString("F0", FrmMain.numberFormat)}"));
                        currentZ = layer.ZHeight;
                        ensureUnhopAfterToolChange = false;
                    }

                    // Prime tool before first extrusion
                    if (primeTool && line.GetFValue('E').HasValue)
                    {
                        replacementLines.Add(new GCodeLine($"G1 E{toolChangeRetractionDistance.ToString("F2", FrmMain.numberFormat)} F{toolChangeRetractionSpeed.ToString(FrmMain.numberFormat)}", toolChangeRetractionSpeed / 60.0));
                        toolPrimed[currentTool - 1] = true;
                        primeTool = false;
                    }

                    // Add next movement of the segment
                    replacementLines.Add(line);

                    // Insert potential tool changes after first G0/G1 code
                    if (toolNumber != currentTool)
                    {
                        // Reset any speed overrides so tool change is not slowed down
                        if (activeRule != null)
                        {
                            replacementLines.Add(new GCodeLine("M220 S100"));
                            activeRule = null;
                        }

                        AddToolChange(replacementLines, currentTool, toolNumber);
                        currentTool = toolNumber;
                        primeTool = !toolPrimed[currentTool - 1];

                        // Make sure we go to the height of the current layer after tool change but only before the first extrusion (see above)
                        ensureUnhopAfterToolChange = true;
                    }
                }
                // Always add it if is no movement
                else
                {
                    replacementLines.Add(line);
                }

                // Deal with custom rules
                OverrideRule rule = GetRule(currentTool, layer.Number, segment);
                if (rule != activeRule)
                {
                    ApplyRule(activeRule, replacementLines, rule);
                    activeRule = rule;
                }
            }
            return segment.LastPosition;
        }

        private static void ApplyRule(OverrideRule activeRule, List<GCodeLine> replacementLines, OverrideRule rule)
        {
            if (rule == null)
            {
                // Reset speed and/or extrusion factor
                if (activeRule.SpeedFactor != 100) { replacementLines.Add(new GCodeLine("M220 S100")); }
                if (activeRule.ExtrusionFactor != 100) { replacementLines.Add(new GCodeLine("M221 S100")); }
            }
            else
            {
                // Apply new speed and/or extrusion factor
                if ((activeRule == null && rule.SpeedFactor != 100) || (activeRule != null && activeRule.SpeedFactor != rule.SpeedFactor))
                {
                    replacementLines.Add(new GCodeLine($"M220 S{rule.SpeedFactor.ToString("F1", FrmMain.numberFormat)}"));
                }
                if ((activeRule == null && rule.ExtrusionFactor != 100) || (activeRule != null && activeRule.ExtrusionFactor != rule.ExtrusionFactor))
                {
                    replacementLines.Add(new GCodeLine($"M221 S{rule.ExtrusionFactor.ToString("F1", FrmMain.numberFormat)}"));
                }
            }
        }

        private void AddToolChange(List<GCodeLine> lines, int oldToolNumber, int newToolNumber)
        {
            if (oldToolNumber > 0 && oldToolNumber <= settings.Tools.Length)
            {
                ToolSettings oldTool = settings.Tools[oldToolNumber - 1];
                if (oldTool.PreheatTime > 0m)
                {
                    lines.Add(new GCodeLine($"G10 P{oldToolNumber} R{oldTool.StandbyTemperature.ToString(FrmMain.numberFormat)}"));
                }
            }

            ToolSettings newTool = settings.Tools[newToolNumber - 1];
            if (newTool.Cleaning == CleaningMode.Always
                || (newTool.Cleaning == CleaningMode.Interval && (newTool.ToolChangeCounter % newTool.Interval) == 0)
                || (newTool.Cleaning == CleaningMode.Once && !newTool.CleanOnceDone))
            {
                lines.Add(new GCodeLine($"M98 P\"tprime{newToolNumber}.g\"{ToolChangeMarker}"));
                newTool.CleanOnceDone = true;
            }
            else
            {
                lines.Add(new GCodeLine($"T{newToolNumber}{ToolChangeMarker}"));
                if (oldToolNumber == -1 || newTool.PreheatTime <= 0m)
                {
                    lines.Add(new GCodeLine($"M116 P{newToolNumber}"));
                }
            }
            ++newTool.ToolChangeCounter;
        }

        public async Task WriteToFile(FileStream stream, bool debug)
        {
            StreamWriter sw = new StreamWriter(stream);
            foreach (GCodeLayer layer in layers)
            {
                foreach (GCodeSegment segment in layer.Segments)
                {
                    foreach (GCodeLine line in segment.Lines)
                    {
                        await sw.WriteLineAsync(debug ? line.DebugLine() : line.Content);
                    }
                }
            }
            sw.Flush();
        }
    }
}
